## 啊 命名 太重要了

### 源代码分支结点

考虑程序 1：

```java
if(n>1919 && list.contains(obj)){ // ①
    // ②
}
else{
    // ③
}
```

①处的 `if` 语句是一个**源代码分支结点 **。

②是该结点的**成真分支**。

③是该结点的**成假分支**。

### 字节码分支结点

上述程序编译成的字节码（准确地说：JVM 指令）

```assembly
   L3
    LINENUMBER 12 L3
    ILOAD 1
    SIPUSH 1919
    IF_ICMPLE L4
    ALOAD 2
    ALOAD 3
    INVOKEVIRTUAL java/util/ArrayList.contains (Ljava/lang/Object;)Z
    IFEQ L4
   L4
    LINENUMBER 17 L4
   FRAME APPEND [I java/util/ArrayList java/lang/Object]
    RETURN
   L5
    LOCALVARIABLE args [Ljava/lang/String; L0 L5 0
    LOCALVARIABLE n I L1 L5 1
    LOCALVARIABLE list Ljava/util/ArrayList; L2 L5 2
    // signature Ljava/util/ArrayList<Ljava/lang/Object;>;
    // declaration: java.util.ArrayList<java.lang.Object>
    LOCALVARIABLE obj Ljava/lang/Object; L3 L5 3
    MAXSTACK = 2
    MAXLOCALS = 4
```

IF_ICMPLE L4 对应 n>1919

IFEQ L4 对应 list.contains(obj)

它们是**字节码分支结点**。

（字节码里爱放“不成立”的情况……“成立则跳转，不成立则继续”）

### 分支结点 := 字节码分支结点

若不加说明地提到“分支结点”，则指字节码分支结点。

### Trace

程序 1，在这个输入下：

```java
int n = 1;
ArrayList<Object> list = new ArrayList<>();
Object obj = new Object();
```

得到的实际执行 trace 为（按 2018-06-04 的记录格式）：

